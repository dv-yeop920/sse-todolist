const chokidar = require('chokidar')
const Debounce = require('../../utils/debounce')
const { join } = require('path')
const { wait } = require('../../utils/')

// const { clearConsole } = require('../../utils/console')
module.exports = (runtime, onChange) => {
  // Gather all connection so we can destroy them in first time when reload
  // let connections = {}
  // server.server.on('connection', function(conn) {
  //   const key = conn.remoteAddress + ':' + conn.remotePort
  //   connections[key] = conn
  //   conn.on('close', () => {
  //     delete connections[key]
  //   })
  // })

  // server.onClose(async (instance, done) => {

  //   // done()
  // })
  let watchList = []

  watchList.push(runtime.project.ENTRY_FILE)
  watchList.push(runtime.project.FE_CONFIG_FILE)
  watchList.push(runtime.project.MOCK_DIR)
  watchList.push(runtime.project.CONFIG_DIR)

  // Don't nest or emit event twice!
  watchList.push(join(runtime.project.appRoot, 'server'))
  watchList.push(join(runtime.project.appRoot, 'middleware'))
  watchList.push(join(runtime.project.appRoot, 'modules'))
  watchList.push(join(runtime.project.appRoot, 'plugins'))

  watchList = watchList.filter(item => item)

  // onChange触发节流
  const onChangeDeb = onChange ? Debounce(onChange, 100) : undefined
  // 清缓存函数节流
  const clearModuleCache = Debounce(() => {
    Object.keys(require.cache).forEach(modulePath => {
      if (
        ~modulePath.indexOf(runtime.project.appRoot) &&
        !~modulePath.indexOf(`${runtime.project.appRoot}/client`) &&
        !~modulePath.indexOf(`${runtime.project.appRoot}/node_modules`)
      ) {
        // for (let key in connections) connections[key].destroy()
        delete require.cache[modulePath]
      }
    })
  }, 10) // 时间一定要小于上边的100
  const watcher = chokidar
    .watch(watchList, {
      ignored: /node_modules|\.git/,
      persistent: true
      // usePolling: true,
      // interval: 100,
      // awaitWriteFinish: {
      //   stabilityThreshold: 2000,
      //   pollInterval: 100
      // }
    })
    .on(
      'ready',
      Debounce(async () => {
        // await wait(100)
        watcher.on('all', async (event, path) => {
          clearModuleCache()
          onChangeDeb &&
            (await onChangeDeb(event, path).catch(e => {
              console.log(e)
            }))
        })
      }, 100)
    )

  return runtime
}
