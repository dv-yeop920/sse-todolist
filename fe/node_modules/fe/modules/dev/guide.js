const { promisify } = require('util')
const writeFile = promisify(require('fs').writeFile)
const { join } = require('path')
const inquirer = require('inquirer')
const chalk = require('chalk')
const syncConfig = require('../../utils/syncConfig')
const { touch, exists } = require('../../utils/fs')
const { inline } = require('../../utils/console')

const entryFiles = {
  vue: 'index.vue',
  react: 'index.js'
}
const entryFilesContent = {
  vue: `<template>
  <div>
    <h1>{{hi}} {{data.hello}}</h1>
    <h2>SSR: {{server}}</h2>
    <p>{{userAgent}}</p>
  </div>
</template>
<script>
export default {
  data () {
    return { hi: 'Hello' }
  },
  async asyncData ({ req, app }) {
    const data = await app.$axios.$get('/api')
    const userAgent = req ? req.headers['user-agent'] : navigator.userAgent
    return { data, server: !!process.server, userAgent }
  }
}
</script>
<style scoped lang="stylus">
h1
  color red
</style>`,
  react: `import React, { Component } from 'react'
import fetch from 'isomorphic-unfetch'

export default class extends Component {
  static async getInitialProps({ req }) {
    const userAgent = req ? req.headers['user-agent'] : navigator.userAgent
    let api = req ? \`http://\$\{req.headers.host\}/api\` : '/api'
    const res = await fetch(api).catch(err => console.log(err))
    const data = await res.json()
    return { userAgent, data }
  }
  render() {
    const {data, userAgent} = this.props
    return (
      <div>
        <h1>Hello {data.hello}</h1>
        <p>{userAgent}</p>
        <style jsx>{\`
        h1 {
          color: red;
        }
        \`}</style>
      </div>
    )
  }
}
`
}

module.exports = async runtime => {
  runtime = runtime || (await require('../runtime/')())

  if (!runtime.project.FE_CONFIG_FILE) {
    inline.error(`Can not found a configuration file ${chalk.green('fe.json')}`)
    const { autoGen } = await inquirer.prompt([
      {
        type: 'confirm',
        name: 'autoGen',
        default: false,
        message: `Do you want generate ${chalk.green(
          'fe.json'
        )} in the current directory?`
      }
    ])
    if (autoGen) {
      await writeFile(runtime.project.config.FE_CONFIG_FILE, '{}')
      runtime = await require('../runtime/')()
    } else {
      inline.info(
        `${chalk.dim('The best way to start a new project: ')}${chalk.magenta(
          'fe init <project> [boilerplate]'
        )}`
      )
      return process.exit()
    }
  }

  let config
  try {
    config = syncConfig(runtime.project.FE_CONFIG_FILE, (prev, next) => {
      // console.log(prev, next)
    })
  } catch (err) {
    inline.error(`Parse failed: ${runtime.project.FE_CONFIG_FILE}`)
    return process.exit()
  }

  if (config.ENTRY_FILE !== null && !runtime.project.ENTRY_FILE) {
    inline.warning(
      `Can not found a server entry file ${chalk.green('index.js')}`
    )
    const { clientOnly } = await inquirer.prompt([
      {
        type: 'confirm',
        name: 'clientOnly',
        default: false,
        message: `Are you sure this is a ${chalk.blue('client-only')} project?`
      }
    ])
    if (clientOnly) {
      // write config
      config.ENTRY_FILE = null
      config.CLIENT_DIR = '.'
      runtime.project.config.CLIENT_DIR = '.'
      runtime.project.CLIENT_DIR = runtime.project.appRoot
    } else {
      await writeFile(
        runtime.project.config.ENTRY_FILE,
        `module.exports = async (app, options) => {
  app.get('/api', async (req, res) => {
    return {
      hello: 'ServerData'
    }
  })
  // app.register(require('./server/modules/user/'), { prefix: '/api/user' })
}`
      )
      config.CLIENT_DIR = 'client'
      config.ENTRY_FILE = 'index.js'

      runtime.project.config.CLIENT_DIR = 'client'
      runtime.project.CLIENT_DIR = join(runtime.project.appRoot, 'client')
    }
  }

  const genClientEntry = async clientEntry => {
    clientEntry =
      clientEntry || join(runtime.project.appRoot, config.CLIENT_DIR, 'pages')
    const { autoGenClientEntry } = await inquirer.prompt([
      {
        type: 'confirm',
        name: 'autoGenClientEntry',
        default: false,
        message: `Do you want generate client entry in the current directory?`
      }
    ])

    if (autoGenClientEntry) {
      let entryFilePath = join(
        clientEntry,
        entryFiles[config.CLIENT_MODE] || 'index.html'
      )
      await touch(entryFilePath)
      await writeFile(
        entryFilePath,
        entryFilesContent[config.CLIENT_MODE] || '<h1>Hello World</h1>'
      )
    } else {
      inline.warning(
        `${chalk.dim('You may manually create a client entry: ')}${chalk.green(
          `${config.CLIENT_DIR}/pages/[${entryFiles[config.CLIENT_MODE]}]`
        )}`
      )
      return process.exit()
    }
  }

  if (config.CLIENT_MODE === undefined) {
    const { clientMode } = await inquirer.prompt([
      {
        type: 'list',
        name: 'clientMode',
        default: 'vue',
        choices: ['vue', 'react', 'none'],
        message: `Please select a front-end framework`
      }
    ])
    runtime.project.config.CLIENT_MODE = config.CLIENT_MODE =
      clientMode === 'none' ? null : clientMode
    await genClientEntry()
  } else if (config.CLIENT_MODE !== null) {
    // check client entry
    const clientEntry = join(
      runtime.project.appRoot,
      config.CLIENT_DIR,
      'pages'
    )
    if (!await exists(clientEntry)) {
      inline.warning(
        `Can not found a client entry ${chalk.green(
          `${config.CLIENT_DIR}/pages/[${entryFiles[config.CLIENT_MODE]}]`
        )}`
      )
      await genClientEntry(clientEntry)
    }
  }
  return runtime
}
