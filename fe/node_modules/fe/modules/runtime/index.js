const { join, delimiter, resolve } = require('path')
const osenv = require('osenv')
const { determineRoot, exists, resolveApp } = require('../../utils/fs')
const { stdout } = require('../../utils/process')
const { assign, keys } = Object

/**
 * Detect usefully runtime info
 * @return {[type]} [description]
 */
module.exports = async (defaultConfig, pkg, opts = {}) => {
  pkg = pkg || require('../../package.json')
  defaultConfig = defaultConfig || require('../../config/fe.json')

  // Read dirname from cli entry
  const dirname = opts.dirname || process.env.DIRNAME
  const cwd = opts.cwd || process.cwd()

  // TODO: May install at ~/.fe
  // const cliRoot = join(require.resolve('fe/package.json'), '..')
  const cliRoot = await determineRoot('package.json', __dirname).catch(
    err => {}
  )

  let config = assign({}, defaultConfig)

  let appRoot =
    (await determineRoot(config.FE_CONFIG_FILE, cwd).catch(err => {})) || null

  let customConfig = {}

  try {
    customConfig = require(join(appRoot, config.FE_CONFIG_FILE))
  } catch (err) {
    // console.log(`Parse ${config.FE_CONFIG_FILE} failed, 'module.exports = {}'`)
  }

  // Merge custom configure
  assign(config, customConfig)

  const npmRoot = await stdout('npm root -g')

  // Delimit NODE_PATH
  const nodePath = (process.env.NODE_PATH || npmRoot)
    .split(delimiter)
    .filter(Boolean)

  // A hack for fix some case module.paths not includes NODE_PATH
  if (!module.paths.includes(npmRoot)) {
    module.paths = module.paths.concat(npmRoot)
  }

  const home = osenv.home()
  const platform = process.platform
  // Locate the cache dir
  // ~/.fe-cache on posix, or %AppData%/fe-cache on windows
  const cacheExtra = platform === 'win32' ? 'fe-cache' : '.fe-cache'
  const cacheRoot = resolve(
    (platform === 'win32' && process.env.APPDATA) || home,
    cacheExtra
  )

  let result = {
    ENV: {
      FE_VERSION: pkg.version,
      NODE_VERSION: await stdout('node -v'),
      NPM_VERSION: await stdout('npm -v'),
      YARN_VERSION: await stdout('yarn -v'),
      nodeBinPath: await stdout('which node'),
      feBinPath: await stdout('which fe'),
      cliRoot,
      platform,
      tmpdir: osenv.tmpdir(),
      home,
      user: osenv.user(),
      pid: process.pid,
      uid: process.getuid(),
      dirname,
      cwd,
      npmRoot,
      cacheRoot,
      nodePath,
      sharedConfigPath: join(cliRoot, 'config'),
      internalModulePath: join(cliRoot, 'node_modules')
    },
    project: {
      config,
      appRoot
    },
    DEFAULT_CONFIG: defaultConfig
    // WEBPACK_VERSION: (pkg.dependencies.webpack + '').replace('^', ''),
    // BABEL_VERSION: (pkg.dependencies['babel-core'] + '').replace('^', ''),
  }

  if (opts.network) {
    result.ENV.inChina = await require('../../utils/isInChina')().catch(err =>
      console.log('network blocked')
    )
  }

  await Promise.all(
    keys(config)
      .filter(key => /(_DIR|_FILE)$/.test(key))
      .map(async key => {
        const dirRoot = /^((?!FE).)*_CONFIG_FILE$|POLYFILLS_FILE$/.test(key)
          ? appRoot ? join(appRoot, 'config') : null
          : appRoot
        const dir = resolveApp(config[key], dirRoot)
        result.project[key] = (await exists(dir)) ? dir : null
      })
  )
  return result
}
